# -*- coding: utf-8 -*-
"""gemini_ai_utils.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wRy7dwkgbPBpNseVuS-1vwbtTowxPjgt
"""

# gemini_ai_utils.py
"""
Utility functions for interacting with the Google Gemini AI.

This script provides functions for analyzing images (thumbnails) and text content
(channel descriptions and video transcripts) using Gemini models.
"""

import google.generativeai as genai
import requests
from io import BytesIO
from PIL import Image
import json

# Import configuration and predefined categories
from config import GEMINI_API_KEY, GEMINI_MULTIMODAL_MODEL, GEMINI_TEXT_MODEL, PREDEFINED_CATEGORIES, MIN_CONTENT_LENGTH_FOR_LLM

# Initialize Gemini AI
genai.configure(api_key=GEMINI_API_KEY)

def get_image_as_pil_image(image_url):
    """
    Downloads an image from a URL and returns it as a PIL Image object.
    Resizes the image to a maximum dimension for efficient API processing.

    Args:
        image_url (str): The URL of the image.

    Returns:
        PIL.Image.Image or None: The PIL Image object if successful, None otherwise.
    """
    try:
        response = requests.get(image_url, timeout=10)
        response.raise_for_status() # Raise an HTTPError for bad responses (4xx or 5xx)

        content_type = response.headers.get('Content-Type', '')
        if not content_type.startswith('image/'):
            print(f"Error: URL did not return an image. Content-Type: {content_type}")
            return None

        img_data = BytesIO(response.content)
        img = Image.open(img_data)

        if img.mode != 'RGB':
            img = img.convert('RGB')

        max_dim = 512
        if max(img.size) > max_dim:
            img.thumbnail((max_dim, max_dim), Image.LANCZOS)

        return img
    except requests.exceptions.RequestException as e:
        print(f"Error downloading image {image_url}: {e}")
        return None
    except Exception as e:
        print(f"Error processing image {image_url}: {e}")
        return None

def analyze_thumbnail_with_gemini(pil_image):
    """
    Analyzes a thumbnail image (PIL Image object) with Gemini AI to infer facial attributes.

    Args:
        pil_image (PIL.Image.Image): The PIL Image object of the thumbnail.

    Returns:
        dict: A dictionary of inferred attributes (face shape, skin color, etc.) and status.
    """
    model = genai.GenerativeModel(GEMINI_MULTIMODAL_MODEL)
    response_data = {
        "llm_thumbnail_face_shape": "unknown",
        "llm_thumbnail_skin_color": "unknown",
        "llm_thumbnail_eye_shape": "unknown",
        "llm_thumbnail_lip_shape": "unknown",
        "llm_thumbnail_status": "unknown"
    }

    if not pil_image:
        response_data["llm_thumbnail_status"] = "error_processing_image"
        return response_data

    prompt_text = f"""
    Analyze the human face in this image.
    1. Determine if there is exactly one clear, straight-facing human face visible. If not, state "skipped_multiple_faces" if multiple faces, or "skipped_no_clear_face" if no clear straight face is visible. In these skipped cases, return 'unknown' for all attribute values.
    2. If a clear, straight-facing face is visible, infer the following attributes based *only* on the image:
        - Face Shape (choose from: {', '.join(PREDEFINED_CATEGORIES['llm_thumbnail_face_shape'][:-1])})
        - Skin Color (choose from: {', '.join(PREDEFINED_CATEGORIES['llm_thumbnail_skin_color'][:-1])})
        - Eye Shape (choose from: {', '.join(PREDEFINED_CATEGORIES['llm_thumbnail_eye_shape'][:-1])})
        - Lip Shape (choose from: {', '.join(PREDEFINED_CATEGORIES['llm_thumbnail_lip_shape'][:-1])})
    3. For any attribute that cannot be confidently determined even if a clear face is present, state 'unknown'.
    4. Return the result as a JSON object with keys: 'face_shape', 'skin_color', 'eye_shape', 'lip_shape', and 'status'.
    Example: {{ "face_shape": "Oval", "skin_color": "Medium", "eye_shape": "Almond", "lip_shape": "Fuller", "status": "analyzed" }}
    Example (skipped): {{ "face_shape": "unknown", "skin_color": "unknown", "eye_shape": "unknown", "lip_shape": "unknown", "status": "skipped_multiple_faces" }}
    """

    # Pass the PIL Image object directly to generate_content
    content_parts = [
        {"text": prompt_text},
        pil_image
    ]

    try:
        response = model.generate_content(content_parts)

        if response and response.text:
            clean_text = response.text.strip()
            if clean_text.startswith('```json') and clean_text.endswith('```'):
                clean_text = clean_text[len('```json'):-len('```')].strip()

            json_response = json.loads(clean_text)
            response_data["llm_thumbnail_face_shape"] = json_response.get("face_shape", "unknown")
            response_data["llm_thumbnail_skin_color"] = json_response.get("skin_color", "unknown")
            response_data["llm_thumbnail_eye_shape"] = json_response.get("eye_shape", "unknown")
            response_data["llm_thumbnail_lip_shape"] = json_response.get("lip_shape", "unknown")
            response_data["llm_thumbnail_status"] = json_response.get("status", "unknown")

            # Validate against predefined categories
            if response_data["llm_thumbnail_face_shape"] not in PREDEFINED_CATEGORIES['llm_thumbnail_face_shape']:
                response_data["llm_thumbnail_face_shape"] = "unknown"
            if response_data["llm_thumbnail_skin_color"] not in PREDEFINED_CATEGORIES['llm_thumbnail_skin_color']:
                response_data["llm_thumbnail_skin_color"] = "unknown"
            if response_data["llm_thumbnail_eye_shape"] not in PREDEFINED_CATEGORIES['llm_thumbnail_eye_shape']:
                response_data["llm_thumbnail_eye_shape"] = "unknown"
            if response_data["llm_thumbnail_lip_shape"] not in PREDEFINED_CATEGORIES['llm_thumbnail_lip_shape']:
                response_data["llm_thumbnail_lip_shape"] = "unknown"
            if response_data["llm_thumbnail_status"] not in PREDEFINED_CATEGORIES['llm_thumbnail_status']:
                response_data["llm_thumbnail_status"] = "error_llm_response"

        else:
            response_data["llm_thumbnail_status"] = "error_llm_response"

    except (json.JSONDecodeError, AttributeError) as e:
        print(f"Error parsing Gemini response for thumbnail: {e}. Raw text: {response.text if response else 'No response text'}")
        response_data["llm_thumbnail_status"] = "error_llm_response"
    except Exception as e:
        print(f"Gemini thumbnail analysis failed: {e}")
        response_data["llm_thumbnail_status"] = "error_llm_response"

    return response_data

def analyze_content_with_gemini(channel_description, video_transcripts_sample):
    """
    Analyzes channel content (description + sample transcripts) with Gemini AI
    to infer content-related attributes using predefined categories.

    Args:
        channel_description (str): The 'About' section description of the channel.
        video_transcripts_sample (str): A concatenated string of recent video transcripts.

    Returns:
        dict: A dictionary of inferred attributes (makeup style, skill level, etc.).
    """
    model = genai.GenerativeModel(GEMINI_TEXT_MODEL)
    combined_text = f"Channel Description: {channel_description}\n\nRecent Video Content:\n{video_transcripts_sample}"

    content_attributes = {
        "features_aligned_with": [],
        "primary_makeup_style": [],
        "target_skill_level": [],
        "demographic_focus": []
    }

    if len(combined_text.strip()) < MIN_CONTENT_LENGTH_FOR_LLM:
        print(f"Content too short for detailed LLM analysis ({len(combined_text.strip())} chars). Skipping.")
        return content_attributes

    max_text_length = 200000
    if len(combined_text) > max_text_length:
        combined_text = combined_text[:max_text_length] + " [...truncated for length...]"

    prompt_text = f"""
    Analyze the following text content from a YouTube channel (description and recent video transcripts).\n    Infer the channel's primary focus based on the categories provided. Select ALL applicable tags for each category.\n    If a category is not applicable or cannot be confidently determined, return an empty array for that category.\n    \n    Predefined Categories:\n    - features_aligned_with (choose from: {', '.join(PREDEFINED_CATEGORIES['face_shape'] + PREDEFINED_CATEGORIES['eye_shape'] + PREDEFINED_CATEGORIES['skin_undertone'] + PREDEFINED_CATEGORIES['skin_type_concerns'] + PREDEFINED_CATEGORIES['lip_shape'] + PREDEFINED_CATEGORIES['other_features'])})\n    - primary_makeup_style (choose from: {', '.join(PREDEFINED_CATEGORIES['primary_makeup_style'])})\n    - target_skill_level (choose from: {', '.join(PREDEFINED_CATEGORIES['target_skill_level'])})\n    - demographic_focus (choose from: {', '.join(PREDEFINED_CATEGORIES['demographic_focus'])})\n\n    Return the result as a JSON object. Ensure all keys from the predefined categories list are present, even if their value is an empty array.\n    Example: {{\n      \"features_aligned_with\": [\"round_face\", \"oily_skin\"],\n      \"primary_makeup_style\": [\"glam\"],\n      \"target_skill_level\": [\"beginner\"],\n      \"demographic_focus\": []\n    }}\n\n    Text Content:\n    {combined_text}\n    """

    try:
        response = model.generate_content(prompt_text)

        if response and response.text:
            clean_text = response.text.strip()
            try:
                if clean_text.startswith('```json') and clean_text.endswith('```'):
                    clean_text = clean_text[len('```json'):-len('```')].strip()
                json_response = json.loads(clean_text)
            except json.JSONDecodeError:
                print(f"Warning: Gemini did not return valid JSON for content analysis. Raw text: {clean_text[:200]}...")
                return content_attributes

            for key in content_attributes.keys():
                extracted_tags = json_response.get(key, [])
                if not isinstance(extracted_tags, list):
                    extracted_tags = []

                valid_tags = []
                allowed_tags = []
                if key == "features_aligned_with":
                    allowed_tags = (PREDEFINED_CATEGORIES['face_shape'] + PREDEFINED_CATEGORIES['eye_shape'] +
                                    PREDEFINED_CATEGORIES['skin_undertone'] + PREDEFINED_CATEGORIES['skin_type_concerns'] +
                                    PREDEFINED_CATEGORIES['lip_shape'] + PREDEFINED_CATEGORIES['other_features'])
                else:
                    allowed_tags = PREDEFINED_CATEGORIES.get(key, [])

                for tag in extracted_tags:
                    if tag in allowed_tags:
                        valid_tags.append(tag)

                content_attributes[key] = valid_tags

    except (json.JSONDecodeError, AttributeError) as e:
        print(f"Error parsing Gemini response: {e}. Raw text: {response.text if response else 'No response response text'}")
    except Exception as e:
        print(f"Gemini content analysis failed: {e}")

    return content_attributes

# Example usage (for individual testing of this module)
if __name__ == "__main__":
    print("--- Testing gemini_ai_utils.py ---")

    # Ensure you have a valid GEMINI_API_KEY in config.py for this to work
    if GEMINI_API_KEY == "YOUR_GEMINI_API_KEY":
        print("Please set your GEMINI_API_KEY in config.py to test this module.")
    else:
        # Test get_image_as_pil_image and analyze_thumbnail_with_gemini
        test_image_url = "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/800px-Ada_Lovelace_portrait.jpg"
        print(f"\nAnalyzing thumbnail from: {test_image_url}")
        test_pil_image = get_image_as_pil_image(test_image_url)
        if test_pil_image:
            thumbnail_attrs = analyze_thumbnail_with_gemini(test_pil_image)
            print("Thumbnail Analysis Result:", json.dumps(thumbnail_attrs, indent=2))
        else:
            print("Skipping thumbnail analysis due to image download/processing error.")

        # Test analyze_content_with_gemini
        test_description = "Welcome to my channel! I share daily makeup tips for beginners and intermediate users. Focus on natural looks and affordable products."
        test_transcripts = "Today we're doing a simple everyday look. I'll show you how to apply foundation for oily skin and a quick eye makeup. This is perfect for beginners."
        print("\nAnalyzing content...")
        content_attrs = analyze_content_with_gemini(test_description, test_transcripts)
        print("Content Analysis Result:", json.dumps(content_attrs, indent=2))

        test_sparse_content = "Hello!"
        print(f"\nAnalyzing sparse content: '{test_sparse_content}'")
        sparse_content_attrs = analyze_content_with_gemini(test_sparse_content, "")
        print("Sparse Content Analysis Result:", json.dumps(sparse_content_attrs, indent=2))

    print("\n--- gemini_ai_utils.py testing complete ---")