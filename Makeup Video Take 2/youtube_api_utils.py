# -*- coding: utf-8 -*-
"""youtube_api_utils.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AhdeU-q3mYDBO0BVq8z_2HssUATJd-HI
"""

# youtube_api_utils.py
"""
Utility functions for interacting with the YouTube Data API.

This script handles fetching channel information, statistics, topics,
and video transcripts from YouTube. It also includes functionality
to translate non-English transcripts to English using Google Gemini AI.
"""

from googleapiclient.discovery import build
from youtube_transcript_api import YouTubeTranscriptApi, NoTranscriptFound, TranscriptsDisabled
import time
import google.generativeai as genai # Added for translation

# Import configuration from a separate file
from config import YOUTUBE_API_KEY, GEMINI_API_KEY, GEMINI_TEXT_MODEL, PREDEFINED_CATEGORIES

# Initialize Gemini AI (ensure this is done only once, typically in main, but here for modular test)
# For individual testing of this module, it's configured here.
# In the main application, genai.configure is handled in gemini_ai_utils.py
if GEMINI_API_KEY != "YOUR_GEMINI_API_KEY":
    genai.configure(api_key=GEMINI_API_KEY)

def get_youtube_service():
    """Builds and returns a YouTube Data API service object."""
    return build('youtube', 'v3', developerKey=YOUTUBE_API_KEY)

def search_youtube_channels(youtube_service, query, region_code='US', max_results=20):
    """
    Searches for YouTube channels based on a query and returns basic channel data.

    Args:
        youtube_service: An initialized YouTube Data API service object.
        query (str): The search query for channels.
        region_code (str): The region code to bias search results (e.g., 'US').
        max_results (int): Maximum number of results to return per query.

    Returns:
        list: A list of dictionaries, each containing basic info for a found channel.
    """
    channels = []
    try:
        search_response = youtube_service.search().list(
            q=query,
            type='channel',
            part='id,snippet',
            maxResults=max_results,
            regionCode=region_code
        ).execute()

        for item in search_response.get('items', []):
            channel_id = item['id']['channelId']
            channel_name = item['snippet']['title']
            channel_description = item['snippet']['description']
            published_at = item['snippet']['publishedAt']
            profile_picture_url = item['snippet']['thumbnails']['high']['url']
            country = item['snippet'].get('country')
            default_language = item['snippet'].get('defaultLanguage')

            # Include channels where country is explicitly 'US' or if country is not specified
            if country == 'US' or country is None:
                channels.append({
                    'channel_id': channel_id,
                    'channel_name': channel_name,
                    'channel_description': channel_description,
                    'published_at': published_at,
                    'profile_picture_url': profile_picture_url,
                    'default_language': default_language,
                    'country': country,
                    'uploads_playlist_id': None # This will be populated in get_channel_statistics_and_topics
                })
    except Exception as e:
        print(f"Error searching channels for query '{query}': {e}")
    return channels

def get_channel_statistics_and_topics(youtube_service, channel_ids):
    """
    Fetches detailed statistics, topic details, and branding settings for given channel IDs.

    Args:
        youtube_service: An initialized YouTube Data API service object.
        channel_ids (list): A list of YouTube channel IDs.

    Returns:
        dict: A dictionary where keys are channel IDs and values are dictionaries
              containing detailed statistics and other information.
    """
    if not channel_ids:
        return {}

    details = {}
    # Process in chunks of 50 as per YouTube API limits
    id_chunks = [channel_ids[i:i + 50] for i in range(0, len(channel_ids), 50)]

    for chunk in id_chunks:
        try:
            channels_response = youtube_service.channels().list(
                part='statistics,topicDetails,contentDetails,brandingSettings',
                id=','.join(chunk)
            ).execute()

            for item in channels_response.get('items', []):
                channel_id = item['id']
                stats = item.get('statistics', {})
                topic_details = item.get('topicDetails', {})
                content_details = item.get('contentDetails', {})
                branding_settings = item.get('brandingSettings', {}).get('channel', {})

                details[channel_id] = {
                    'subscriber_count': int(stats.get('subscriberCount', 0)),
                    'video_count': int(stats.get('videoCount', 0)),
                    'total_view_count': int(stats.get('viewCount', 0)),
                    'topic_ids': topic_details.get('topicIds', []),
                    'uploads_playlist_id': content_details.get('relatedPlaylists', {}).get('uploads'),
                    'keywords': branding_settings.get('keywords', '').split(',') if isinstance(branding_settings.get('keywords'), str) else branding_settings.get('keywords', [])
                }
        except Exception as e:
            print(f"Error fetching details for channel IDs {chunk}: {e}")
    return details

def get_last_video_upload_timestamp(youtube_service, uploads_playlist_id):
    """
    Fetches the timestamp of the most recent video in an uploads playlist.

    Args:
        youtube_service: An initialized YouTube Data API service object.
        uploads_playlist_id (str): The ID of the channel's uploads playlist.

    Returns:
        str or None: ISO 8601 timestamp of the last upload, or None if not found/error.
    """
    if not uploads_playlist_id:
        return None
    try:
        playlist_items_response = youtube_service.playlistItems().list(
            part='snippet',
            playlistId=uploads_playlist_id,
            maxResults=1,
            fields='items/snippet/publishedAt'
        ).execute()

        if playlist_items_response.get('items'):
            return playlist_items_response['items'][0]['snippet']['publishedAt']
    except Exception as e:
        # Suppress specific errors like playlist not found, just return None
        pass
    return None

def translate_text_with_gemini(text, source_language_code):
    """
    Translates text to English using the Gemini LLM.

    Args:
        text (str): The text to translate.
        source_language_code (str): The language code of the source text (e.g., 'es', 'fr').

    Returns:
        str: The translated English text, or the original text if translation fails.
    """
    if not text:
        return ""

    # Ensure Gemini is configured (should be done once in main or gemini_ai_utils)
    # This check is primarily for standalone testing of this module.
    if not genai.get_default_model():
        if GEMINI_API_KEY != "YOUR_GEMINI_API_KEY":
            genai.configure(api_key=GEMINI_API_KEY)
        else:
            print("Warning: Gemini API key not configured for translation. Skipping translation.")
            return text # Return original text if API key is not set

    model = genai.GenerativeModel(GEMINI_TEXT_MODEL)
    prompt = f"Translate the following {source_language_code} text to English: \"{text}\""

    try:
        response = model.generate_content(prompt)
        if response and response.text:
            # Basic cleaning: remove markdown code blocks if present
            clean_text = response.text.strip()
            if clean_text.startswith('```') and clean_text.endswith('```'):
                # Attempt to remove language hint (e.g., ```en\n)
                clean_text = clean_text[3:-3].strip()
                if clean_text.lower().startswith('en\n'):
                    clean_text = clean_text[3:].strip()
            return clean_text
        else:
            print(f"Warning: Gemini translation failed for text (from {source_language_code}). No response text.")
            return text # Return original text on no response
    except Exception as e:
        print(f"Error during Gemini translation (from {source_language_code}): {e}")
        return text # Return original text on error
    finally:
        time.sleep(0.5) # Small delay to respect API rate limits

def get_video_transcripts(video_id):
    """
    Fetches transcripts for a given video ID and converts them to English if not already.

    Args:
        video_id (str): The ID of the YouTube video.

    Returns:
        str or None: The full transcript text in English, or None if no transcript is available or an error occurs.
    """
    try:
        transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)

        # Prioritize English (human-generated then auto-generated)
        english_transcript = None
        for t in transcript_list:
            if t.language_code == 'en' and not t.is_generated:
                english_transcript = t
                break
        if not english_transcript:
            for t in transcript_list:
                if t.language_code == 'en' and t.is_generated:
                    english_transcript = t
                    break

        # If no English transcript, try to find any available transcript for translation
        if not english_transcript:
            # Find the first available transcript regardless of language
            for t in transcript_list:
                english_transcript = t # Assign any found transcript
                break

        if english_transcript:
            full_transcript_content = " ".join([item['text'] for item in english_transcript.fetch()])

            # If the found transcript is not English, translate it
            if english_transcript.language_code != 'en':
                print(f"  Found {english_transcript.language_code} transcript for {video_id}. Translating to English...")
                translated_content = translate_text_with_gemini(full_transcript_content, english_transcript.language_code)
                return translated_content
            else:
                return full_transcript_content
        else:
            return None # No transcript found at all
    except TranscriptsDisabled:
        # print(f"Transcripts are disabled for video {video_id}.")
        return None
    except NoTranscriptFound:
        # print(f"No transcript found for video {video_id}.")
        return None
    except Exception as e:
        # print(f"Error fetching or processing transcript for video {video_id}: {e}")
        return None

# Example usage (for individual testing of this module)
if __name__ == "__main__":
    print("--- Testing youtube_api_utils.py ---")

    # Ensure you have valid API_KEYs in config.py for this to work
    if YOUTUBE_API_KEY == "YOUR_YOUTUBE_API_KEY":
        print("Please set your YOUTUBE_API_KEY in config.py to test YouTube API functions.")
    if GEMINI_API_KEY == "YOUR_GEMINI_API_KEY":
        print("Please set your GEMINI_API_KEY in config.py to test transcript translation.")

    youtube_service = get_youtube_service()

    # Test search_youtube_channels
    print("\nSearching for 'makeup artist' channels...")
    test_channels = search_youtube_channels(youtube_service, 'makeup artist', max_results=2)
    for ch in test_channels:
        print(f"  Found: {ch['channel_name']} ({ch['channel_id']})")

    if test_channels:
        # Test get_channel_statistics_and_topics
        test_channel_ids = [ch['channel_id'] for ch in test_channels]
        print(f"\nFetching stats for {len(test_channel_ids)} channels...")
        channel_details = get_channel_statistics_and_topics(youtube_service, test_channel_ids)
        for ch_id, details in channel_details.items():
            print(f"  Channel ID: {ch_id}, Subscribers: {details.get('subscriber_count')}, Uploads Playlist: {details.get('uploads_playlist_id')}")

            # Test get_last_video_upload_timestamp
            if details.get('uploads_playlist_id'):
                last_upload = get_last_video_upload_timestamp(youtube_service, details['uploads_playlist_id'])
                print(f"    Last Upload: {last_upload}")

                # Test get_video_transcripts with a known non-English video (if you have one)
                # For a real test, you'd need a video ID with a non-English transcript.
                # Example with a placeholder video ID (replace with actual if testing)
                # This video ID has a Spanish auto-generated transcript: "z-R_00V4b9Q"
                # This video ID has English: "iUe3o2e0220"
                test_video_id_english = "iUe3o2e0220"
                test_video_id_spanish = "z-R_00V4b9Q"

                print(f"\nAttempting to fetch and translate transcript for video ID: {test_video_id_english} (English expected)")
                transcript_english = get_video_transcripts(test_video_id_english)
                if transcript_english:
                    print(f"  English Transcript (first 200 chars): {transcript_english[:200]}...")
                else:
                    print("  No English transcript found or error for this video.")

                if GEMINI_API_KEY != "YOUR_GEMINI_API_KEY":
                    print(f"\nAttempting to fetch and translate transcript for video ID: {test_video_id_spanish} (Spanish expected, then translated)")
                    transcript_spanish = get_video_transcripts(test_video_id_spanish)
                    if transcript_spanish:
                        print(f"  Translated Spanish Transcript (first 200 chars): {transcript_spanish[:200]}...")
                    else:
                        print("  No Spanish transcript found or error for this video.")
                else:
                    print("\nSkipping non-English transcript translation test as GEMINI_API_KEY is not set.")

    else:
        print("No test channels found for detailed testing.")
    print("\n--- youtube_api_utils.py testing complete ---")